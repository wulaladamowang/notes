# 第一部分 简介
## 第一章 温故而知新
### 1.1 从Hello World说起
### 1.2 万变不离其宗
- 南桥：专门处理低速设备
- 北桥：连接高速芯片
- SMP(Symmetrical  Multi-Processing):对称多处理器
- MP(Multi-core Processor):多核心处理器，只保留多个核心，共享比较昂贵的缓存部件
### 1.3 站的高，看的远
- 接口:每个层次之间都要相互通信，既然需要通信就必须需要一个通信协议，我们一般称其为接口。
- 从整个层次结构来看，开发工具和应用程序是属于同一个层次的，因为它们都使用一个接口，那就是操作系统应用程序编程接口。应用程序接口的提供者是运行库，什么样的运行库提供什么样的API,比如在Linux下的Glibc库提供POSIX的API,Windows提供Windows API。
- 运行库使用操作系统提供的系统调用接口(System call interface),系统调用接口在实现中往往以软件中断的方式提供哦你，如Linux使用0x80作为系统调用接口。o
- 硬件规格(Hareware Specification):硬件规格定义了操作系统内核，即驱动程序如何操作硬件，如何与硬件进行通信。
- 总结：应用程序需要使用硬件，首先通过调用系统的API,通过中断进入内核，通过内核中的驱动程序调用相应的硬件。
### 1.4 操作系统做什么
- 提供抽象的接口；管理硬件资源
### 1.5 内存不够怎么办
- 分段、分页、虚拟内存
### 1.6 众人拾柴火焰高
- 线程(Thread)：又名轻量级进程(Lightweight Process,LWP)
  - 组成：线程ID、当前指令指针、寄存器合集、堆栈
- 线程安全：同步与锁
- 三种线程模型
### 1.7 本章小结
# 第二部分 静态链接
## 第二章 编译和链接
### 2.1 被隐藏了什么
- 构建：将编译和链接合并到一起的过程。
- 构建过程的四个步骤：
  - 预处理(Prepressing):.c -> .i  参数：-E
    - 将所有的宏定义删除，并且展开所有的宏定义
    - 处理所有的预编译指令，如#if，#ifdef
    - 处理所有的#include预编译指令，将被包含的文件插入该预编译指令的位置，该过程递归进行
    - 删除所有的注释
    - 添加行号和文件名标识，比如#2”hello.c"2,便于编译时期产生调试用的行号信息以及编译时期产生编译错误或警告信息时能够显示行号。
    - 保留所有的#pragma编译器指令，因为编译器必须要使用他们
      - #pragma是编译器指令，用于指示编译器完成一些特定的动作
      - #pragma 所定义的很多指示字是编译器和操作系统特有的
      - #prama在不同的编译器之间是不可移植的
        - 预处理将忽略#pragma指令
        - 当编译器遇到不认识的#pragma指令时，就会忽略该条指令
        - 两个不同的编译器可能以两种不同的方式解释同一条#pragma指令
        - 一般用法：#pragma parameter
          - message:在大多数的编译器中有相似的信息，在编译时输出消息到编译输出窗口,可以用于代码的版本控制。GCC无法使用,VC实现
          - pack：
                  - 不同类型的数据在内存中按照一定的规则排列;而不是按照顺序一个接一个的排放。
                  - struct内存对齐问题：
                        - 第一个起始于0偏移块
                        - 每个成员按照其类型的大小和指定对齐参数n中比较小的一个进行对齐操作
                                 - 偏移位置与成员占用大小均需要对齐,偏移位置必须为对齐大小的整数倍
                                 - 结构体成员的对齐参数为其所有成员使用的对齐参数的最大值
                        - 结构体总长度必须为所有对齐参数的整数倍

          |对齐参数|结构体内部成员|起始位置|占用大小|是否nop|
          |---|---|---|---|---|
          |1|char|0|1|1|
          |2|short|2|2|0|
          |1|char|4|1|3|
          |4|int|8|4|0|
         ```c
         #pragma pack(8)
         struct s1 {
           short a;
           long b;
         };

        struct s2 {
           char c;
           struct s1 d;
           double e;
         };
         ```

         |对齐参数|结构体内部成员|起始位置|占用大小|是否nop|
         |---|---|---|---|---|
         |2|short|0|2|2|
         |4|long|4|4|0|
         总共占用8个字节,同时,最小对齐数为4
         |对齐参数|结构体内部成员|起始位置|占用大小|是否nop|
         |---|---|---|---|---|
         |1|char|0|1|3|
         |4|struct s1|4|8|4|
         |8|double|16|8|0|
         总共占用24个字节,注意在struct s1进行计算时,采用的是最小对齐数
         在上述操作时,VC支持8字节支持,可以实现,但是gcc不会输出上述,不支持8字节对齐
  - 编译(Compilation):参数-S,可以使用cc1将预编译与编译两个步骤合并 .c->.i->.s
    - 扫描:扫描器
    - 词法分析:运用类似于有限状态机的模型将源代码分解成一系列的记号,一般将记号分为:关键字,标识符,字面量,特殊符号.可以使用lex程序实现词法分析,上述过程会生成一个类似表格的记号表.
    - 语法分析:对扫描器产生的记号进行语法分析,从而生成语法树,分析过程采用上下文无关语法,可以使用Yacc完成上述操作
    - 语义分析:语法分析只能完成语法表达式语法层面的分析,不了解语句的真正含义,如两个指针做乘法没有意义.编译器所做的分析的语义是静态语义,即编译期间能够确定的语义,动态语义是指运行时期才能确定的语义.静态语义一般包括:声明和类型的匹配,类型的转换.经过语义分析之后,整个语法树的表达式都被标识了类型,如果有些类型需要类型转换,则语法树会插入相应的转换节点.
    - 源代码优化:一些整数的加减操作在编译器就可以操作(整数没有赋值操作),则被优化.首先将语法树转化为中间代码,如三地址码.
    - 代码生成:代码转换器将中间代码转换成目标机器代码.
    - 目标代码优化:目标代码优化器对上述目标代码进行进一步优化,对于定义在其他模块的变量,需要通过链接器才能完成.
  - 汇编(Assemble):参数-c,或者使用汇编器as .s->.o
    - 将汇编代码转变成机器可执行的指令
  - 链接(Linking):.o -> 可执行程序 链接器ld
### 2.2 编译器做了什么
   - 见上述编译
### 2.3 链接器年龄比编译器长
   - 重定位:重新计算各个目标的地址的过程.
### 2.4 模块拼接-静态链接
   - 链接:将各个源代码进行独立地编译,按照要求将其组装起来的过程.
   - 链接过程:
        - 地址和空间的分配
        - 符号决议(符号绑定)
        - 重定位:地址修正的过程 重定位入口:每一个被修正的地方称为一个重定位入口.
   - 运行时库(Runtime Library):支持程序运行的基本函数的集合
## 第3章 目标文件里有什么
### 3.1 目标文件的格式
- PC平台流行的可执行文件格式有Windows下的PE(portable Executable)和Linux下的ELF(Executable Linkable Format),它们都是COPP(common File format)的变种.
- 目标文件就是源代码编译后但未进行链接的那些中间文件(Win下的.obj和Linux下的.o),它跟可执行文件的内容和结构很相似,所以跟可执行文件格式采用一种格式存储.
- ELF文件标准里将系统采用ELF格式的文件归为如下:

  | ELF文件类型|说明|实例|
  |---|---|---|
  |可重定位文件(Relocatable File)|这类文件包含数据和代码,用来链接成可执行文件或共享目标文件,静态链接库也是这一类|Linux下的.o,Windows下的.obj|
  |可执行文件(Executable File)|这类文件包含了直接可以执行的程序,它的代表就是ELF可执行文件,一般没有扩展名|Windows的.exe文件,bash文件等|
  |共享目标文件(Shared Object File)|包含数据和代码,可以通过链接器与其他的可定位文件和共享文件链接形成新的目标文件；可以使用动态链接器将这几个共享目标文件与可执行文件结合,作为进程映像的一部分来运行|Linux的.so,Windows的Dll|
  |核心转储文件(Core Dump File)|当进行意外终止时,系统可以将该进程的地址空间的内容及终止时的一些其他信息转储到核心转储文件|Linux下的core dump|
- linux 下使用file查看相应的文件格式:例子:file foobar.o
- 目标格式与可执行文件格式跟操作系统和编译器密切相关,所以不同的系统平台下有不同的格式,但是格式是大同小异的.
### 3.2 目标文件是什么样的
- 目标文件的内容至少有编译后的机器指令代码数据,还有链接时的一些信息,如符号表,调试信息,字符串等.一般目标文件按照信息的不同属性将其以"节"的形式存储,有时候也称为"段",表示一个一定长度的区域,唯一的区别是在ELF的链接视图和装载视图的时候.
  |结构|内容|
  |---|---|
  |文件头|描述了整个文件的属性,包括文件是否可执行,是静态链接还是动态链接以及入口地址(如果是可执行文件),目标硬件,目标操作系统等,还包括一个段表(Section Table),描述文件中各个段在文件中的偏移位置以及段的属性|
  |各个段|各个段的内容,如代码段保存的就是程序的指令,数据段保存的就是程序的静态变量等|
  |.text|编译后的执行语句|
  |.data|已经初始化的全局变量和局部静态变量|
  |.bss|未初始化的全局变量和局部静态变量,默认值为0,为其预留位置,在文件中没有内容,只存在于虚拟空间而不存在于物理空间|
- 指令和数据分开存储的好处:
  - 数据是可读可写的,指令是只读的,可以对两个虚拟内存的权限分别设置,防止指令被有意或者无意的篡改.
  - 利用局部性原理,提高cpu cache缓存的命中率.
  - 当系统中运行多个程序的副本时,可以共享指令,读改变的数据区域进行拷贝,可以减小内存的使用.
### 3.3挖掘SimpleSection.o
- objdump -h(--section-headers --headers):将ELF文件的各个段的基本信息打印出来,-x(--all-headers)可以将更多的信息打印出来.
  - 属性中的CONTENTS表示段在文件中存在,.bss段没有CONTENTS属性.
- size命令可以查看ELF文件中的代码段,数据段和BSS段的长度,dec表示三个段长度和的十进制表示,hex为十六进制表示.
#### 3.3.1 代码段
- objdump -s(--full-contents)将所有段的内容以十六进制的方式打印出来,-d(--disassemble=[=symbol])将所包含指令的段反汇编.
#### 3.3.2 数据段和只读数据段
- 设置.rodata只读数据段可以支持const变量和字符串常量,同时将该区域映射成只读,可以保证程序的安全性.
#### 3.3.3 BSS段
- 不同的编译器不同的语言可能不会将全局的未初始化变量存放.bss段,只是预留一个未定义的全局变量符号,等到最终链接成可执行文件时再在.bss段分配空间,编译器内部可见的静态变量的确放在.bss段.
#### 3.3.4其他段
| 常用的段名| 说明|
|---|---|
|.rodata1|Read only data, 只读数据,比如字符串常量,全局const变量,跟.rodata一样|
|.comment|存放的是编译器信息,如字符串:"GCC:(GUN)4.2.0"|
|.debug|调试信息|
|.dynamic|动态链接信息|
|.hash|符号哈希表|
|.line|调试信息的行号,即源代码行号与编译后指令的对应表|
|.note|额外的编译器信息,如程序的公司名,发布版本号等|
|.strtab|String Table.字符串表,用于存储ELF文件中用到的各种字符串|
|.symtab|Symbol Table.符号表|
|.shstrtab|Section String Table.段表名|
|.plt .got|动态链接的跳转表和全局入口表|
|.init, .fini|程序初始化和终结代码段|
- .为前缀表明系统保留的,可以应用程序自定义段名,但是不能以.为前缀.
- 段名可以重复
- 使用objcopy可以将一个二进制文件如图片,MP3等作为目标文件的一个段.
- GCC:在全局变量或者函数之前加上"__attribute__((section("name")))"属性可以将相应的变量或者函数放到以"name"作为段名的段中.
### 3.4 ELF文件结构描述
-






