# 第一部分 简介
## 第一章 温故而知新
### 1.1 从Hello World说起
### 1.2 万变不离其宗
- 南桥：专门处理低速设备
- 北桥：连接高速芯片
- SMP(Symmetrical  Multi-Processing):对称多处理器
- MP(Multi-core Processor):多核心处理器，只保留多个核心，共享比较昂贵的缓存部件
### 1.3 站的高，看的远
- 接口:每个层次之间都要相互通信，既然需要通信就必须需要一个通信协议，我们一般称其为接口。
- 从整个层次结构来看，开发工具和应用程序是属于同一个层次的，因为它们都使用一个接口，那就是操作系统应用程序编程接口。应用程序接口的提供者是运行库，什么样的运行库提供什么样的API,比如在Linux下的Glibc库提供POSIX的API,Windows提供Windows API。
- 运行库使用操作系统提供的系统调用接口(System call interface),系统调用接口在实现中往往以软件中断的方式提供哦你，如Linux使用0x80作为系统调用接口。o
- 硬件规格(Hareware Specification):硬件规格定义了操作系统内核，即驱动程序如何操作硬件，如何与硬件进行通信。
- 总结：应用程序需要使用硬件，首先通过调用系统的API,通过中断进入内核，通过内核中的驱动程序调用相应的硬件。
### 1.4 操作系统做什么
- 提供抽象的接口；管理硬件资源
### 1.5 内存不够怎么办
- 分段、分页、虚拟内存
### 1.6 众人拾柴火焰高
- 线程(Thread)：又名轻量级进程(Lightweight Process,LWP)
  - 组成：线程ID、当前指令指针、寄存器合集、堆栈
- 线程安全：同步与锁
- 三种线程模型
### 1.7 本章小结
# 第二部分 静态链接
## 第二章 编译和链接
### 2.1 被隐藏了什么
- 构建：将编译和链接合并到一起的过程。
- 构建过程的四个步骤：
  - 预处理(Prepressing):.c -> .i  参数：-E
    - 将所有的宏定义删除，并且展开所有的宏定义
    - 处理所有的预编译指令，如#if，#ifdef
    - 处理所有的#include预编译指令，将被包含的文件插入该预编译指令的位置，该过程递归进行
    - 删除所有的注释
    - 添加行号和文件名标识，比如#2”hello.c"2,便于编译时期产生调试用的行号信息以及编译时期产生编译错误或警告信息时能够显示行号。
    - 保留所有的#pragma编译器指令，因为编译器必须要使用他们
      - #pragma是编译器指令，用于指示编译器完成一些特定的动作
      - #pragma 所定义的很多指示字是编译器和操作系统特有的
      - #prama在不同的编译器之间是不可移植的
        - 预处理将忽略#pragma指令
        - 当编译器遇到不认识的#pragma指令时，就会忽略该条指令
        - 两个不同的编译器可能以两种不同的方式解释同一条#pragma指令
        - 一般用法：#pragma parameter
          - message:在大多数的编译器中有相似的信息，在编译时输出消息到编译输出窗口,可以用于代码的版本控制。GCC无法使用,VC实现
          - pack：
                  - 不同类型的数据在内存中按照一定的规则排列;而不是按照顺序一个接一个的排放。
                  - struct内存对齐问题：
                        - 第一个起始于0偏移块
                        - 每个成员按照其类型的大小和指定对齐参数n中比较小的一个进行对齐操作
                                 - 偏移位置与成员占用大小均需要对齐,偏移位置必须为对齐大小的整数倍
                                 - 结构体成员的对齐参数为其所有成员使用的对齐参数的最大值
                        - 结构体总长度必须为所有对齐参数的整数倍

          |对齐参数|结构体内部成员|起始位置|占用大小|是否nop|
          |---|---|---|---|---|
          |1|char|0|1|1|
          |2|short|2|2|0|
          |1|char|4|1|3|
          |4|int|8|4|0|
         ```c
         #pragma pack(8)
         struct s1 {
           short a;
           long b;
         };

        struct s2 {
           char c;
           struct s1 d;
           double e;
         };
         ```

         |对齐参数|结构体内部成员|起始位置|占用大小|是否nop|
         |---|---|---|---|---|
         |2|short|0|2|2|
         |4|long|4|4|0|
         总共占用8个字节,同时,最小对齐数为4
         |对齐参数|结构体内部成员|起始位置|占用大小|是否nop|
         |---|---|---|---|---|
         |1|char|0|1|3|
         |4|struct s1|4|8|4|
         |8|double|16|8|0|
         总共占用24个字节,注意在struct s1进行计算时,采用的是最小对齐数
         在上述操作时,VC支持8字节支持,可以实现,但是gcc不会输出上述,不支持8字节对齐
  - 编译(Compilation):参数-S,可以使用cc1将预编译与编译两个步骤合并 .c->.i->.s
    - 扫描:扫描器
    - 词法分析:运用类似于有限状态机的模型将源代码分解成一系列的记号,一般将记号分为:关键字,标识符,字面量,特殊符号.可以使用lex程序实现词法分析,上述过程会生成一个类似表格的记号表.
    - 语法分析:对扫描器产生的记号进行语法分析,从而生成语法树,分析过程采用上下文无关语法,可以使用Yacc完成上述操作
    - 语义分析:语法分析只能完成语法表达式语法层面的分析,不了解语句的真正含义,如两个指针做乘法没有意义.编译器所做的分析的语义是静态语义,即编译期间能够确定的语义,动态语义是指运行时期才能确定的语义.静态语义一般包括:声明和类型的匹配,类型的转换.经过语义分析之后,整个语法树的表达式都被标识了类型,如果有些类型需要类型转换,则语法树会插入相应的转换节点.
    - 源代码优化:一些整数的加减操作在编译器就可以操作(整数没有赋值操作),则被优化.首先将语法树转化为中间代码,如三地址码.
    - 代码生成:代码转换器将中间代码转换成目标机器代码.
    - 目标代码优化:目标代码优化器对上述目标代码进行进一步优化,对于定义在其他模块的变量,需要通过链接器才能完成.
  - 汇编(Assemble):参数-c,或者使用汇编器as .s->.o
    - 将汇编代码转变成机器可执行的指令
  - 链接(Linking):.o -> 可执行程序 链接器ld
### 2.2 编译器做了什么
   - 见上述编译
### 2.3 链接器年龄比编译器长
   - 重定位:重新计算各个目标的地址的过程.
### 2.4 模块拼接-静态链接
   - 链接:将各个源代码进行独立地编译,按照要求将其组装起来的过程.
   - 链接过程:
        - 地址和空间的分配
        - 符号决议(符号绑定)
        - 重定位:地址修正的过程 重定位入口:每一个被修正的地方称为一个重定位入口.
   - 运行时库(Runtime Library):支持程序运行的基本函数的集合
## 第3章 目标文件里有什么
### 3.1 目标文件的格式
- PC平台流行的可执行文件格式有Windows下的PE(portable Executable)和Linux下的ELF(Executable Linkable Format),它们都是COPP(common File format)的变种.
- 目标文件就是源代码编译后但未进行链接的那些中间文件(Win下的.obj和Linux下的.o),它跟可执行文件的内容和结构很相似,所以跟可执行文件格式采用一种格式存储.
- ELF文件标准里将系统采用ELF格式的文件归为如下:

  | ELF文件类型|说明|实例|
  |---|---|---|
  |可重定位文件(Relocatable File)|这类文件包含数据和代码,用来链接成可执行文件或共享目标文件,静态链接库也是这一类|Linux下的.o,Windows下的.obj|
  |可执行文件(Executable File)|这类文件包含了直接可以执行的程序,它的代表就是ELF可执行文件,一般没有扩展名|Windows的.exe文件,bash文件等|
  |共享目标文件(Shared Object File)|包含数据和代码,可以通过链接器与其他的可定位文件和共享文件链接形成新的目标文件；可以使用动态链接器将这几个共享目标文件与可执行文件结合,作为进程映像的一部分来运行|Linux的.so,Windows的Dll|
  |核心转储文件(Core Dump File)|当进行意外终止时,系统可以将该进程的地址空间的内容及终止时的一些其他信息转储到核心转储文件|Linux下的core dump|
- linux 下使用file查看相应的文件格式:例子:file foobar.o
- 目标格式与可执行文件格式跟操作系统和编译器密切相关,所以不同的系统平台下有不同的格式,但是格式是大同小异的.
### 3.2 目标文件是什么样的
- 目标文件的内容至少有编译后的机器指令代码数据,还有链接时的一些信息,如符号表,调试信息,字符串等.一般目标文件按照信息的不同属性将其以"节"的形式存储,有时候也称为"段",表示一个一定长度的区域,唯一的区别是在ELF的链接视图和装载视图的时候.
  |结构|内容|
  |---|---|
  |文件头|描述了整个文件的属性,包括文件是否可执行,是静态链接还是动态链接以及入口地址(如果是可执行文件),目标硬件,目标操作系统等,还包括一个段表(Section Table),描述文件中各个段在文件中的偏移位置以及段的属性|
  |各个段|各个段的内容,如代码段保存的就是程序的指令,数据段保存的就是程序的静态变量等|
  |.text|编译后的执行语句|
  |.data|已经初始化的全局变量和局部静态变量|
  |.bss|未初始化的全局变量和局部静态变量,默认值为0,为其预留位置,在文件中没有内容,只存在于虚拟空间而不存在于物理空间|
- 指令和数据分开存储的好处:
  - 数据是可读可写的,指令是只读的,可以对两个虚拟内存的权限分别设置,防止指令被有意或者无意的篡改.
  - 利用局部性原理,提高cpu cache缓存的命中率.
  - 当系统中运行多个程序的副本时,可以共享指令,读改变的数据区域进行拷贝,可以减小内存的使用.
### 3.3挖掘SimpleSection.o
- objdump -h(--section-headers --headers):将ELF文件的各个段的基本信息打印出来,-x(--all-headers)可以将更多的信息打印出来.
  - 属性中的CONTENTS表示段在文件中存在,.bss段没有CONTENTS属性.
- size命令可以查看ELF文件中的代码段,数据段和BSS段的长度,dec表示三个段长度和的十进制表示,hex为十六进制表示.
#### 3.3.1 代码段
- objdump -s(--full-contents)将所有段的内容以十六进制的方式打印出来,-d(--disassemble=[=symbol])将所包含指令的段反汇编.
#### 3.3.2 数据段和只读数据段
- 设置.rodata只读数据段可以支持const变量和字符串常量,同时将该区域映射成只读,可以保证程序的安全性.
#### 3.3.3 BSS段
- 不同的编译器不同的语言可能不会将全局的未初始化变量存放.bss段,只是预留一个未定义的全局变量符号,等到最终链接成可执行文件时再在.bss段分配空间,编译器内部可见的静态变量的确放在.bss段.
#### 3.3.4其他段
| 常用的段名| 说明|
|---|---|
|.rodata1|Read only data, 只读数据,比如字符串常量,全局const变量,跟.rodata一样|
|.comment|存放的是编译器信息,如字符串:"GCC:(GUN)4.2.0"|
|.debug|调试信息|
|.dynamic|动态链接信息|
|.hash|符号哈希表|
|.line|调试信息的行号,即源代码行号与编译后指令的对应表|
|.note|额外的编译器信息,如程序的公司名,发布版本号等|
|.strtab|String Table.字符串表,用于存储ELF文件中用到的各种字符串|
|.symtab|Symbol Table.符号表|
|.shstrtab|Section String Table.段表名|
|.plt .got|动态链接的跳转表和全局入口表|
|.init, .fini|程序初始化和终结代码段|
- .为前缀表明系统保留的,可以应用程序自定义段名,但是不能以.为前缀.
- 段名可以重复
- 使用objcopy可以将一个二进制文件如图片,MP3等作为目标文件的一个段.
- GCC:在全局变量或者函数之前加上"__attribute__((section("name")))"属性可以将相应的变量或者函数放到以"name"作为段名的段中.
### 3.4 ELF文件结构描述
  |结构|
  |---|
  |ELF Header|
  |.text|
  |.data|
  |.bss|
  |...<br>other sections|
  |Section header table|
  |String Tables<br>Symbol Tables|
#### 3.4.1 文件头
- 定义位置:/usr/include/elf.h中
- 使用readelf命令来详细查看ELF文件. 参数-h(--file-header)
- 文件头定义的内容有ELF魔数,文件机器字节长度,数据存储方式,版本,运行平台,ABI版本,ELF重定位类型,硬件平台,硬件平台版本,入口地址,程序头入口和长度,段表的位置和长度以及段的数量等.
- 文件头的版本有ELF32\_Ehdr和ELF64\_Ehdr.
- ELF魔数:e\_ident成员表示,最开始的4个字节是所有的ELF文件都必须相同的表示,0x7f,0x45,0x4c,0x46.这四个字节称为ELF文件的魔数,接下来的一个字节是标识ELF文件的文件类的,32位为0x01,64位为0x02.第6个字节是标识字节序的,大小端,第7个字节规定ELF文件的主版本号,一般是1,自1.2版本之后就没有再更新了,后面9个没有定义,一般为0,有些平台使其为扩展标志.
- 文件类型:e\_type,可重定位文件,可执行文件,共享文件每个对应一个常量,通过该常量可以判断文件的类型,而不是通过文件的扩展名.- 机器类型:ELF文件格式可以在多个平台下使用,但是,不代表同一个ELF文件可以在不同的平台下使用,而是表示不同平台下的ELF文件都尊需同一套ELF标准.e\_machine表示该ELF文件的平台属性,表示该文件只能在该平台下使用.
#### 3.4.2 段表
- 段表(Section Header Table):保存ELF文件中段的基本属性的结构,主要包含信息有:段名,段的长度,在文件中的偏移,读写权限以及段的其他属性.它是编译器,链接器以及装载器定位和访问各个段的依据.其本身的位置由e\_shoff成员决定.
- readelf -S(--section-headers) 可以显示段表的内容.段表是以ELF32\_Shdr结构体为元素的数组,每个结构体对应一个段,Elf32\_Shdr又被称为段描述符.第一个元素为无效的描述符,类型为"NULL".
- 段的类型:段的名字只在编译和链接过程中有意义,而对操作系统而言,一个段的属性和权限由段的类型和标志位两个成员来决定.
#### 3.4.3 重定位表 代码或者数据在文件中的绝对引用在后续过程中需要重定位,每个需要重定位,其对应相应的重定位表.
#### 3.4.4 字符串表
- 将用到的变量和段名保存在字符串表中,在引用时只需要引用下标,保存.strtab或.shstrtab分别表示字符串表和段表字符串表(String table and Section header string table),e\_shstrndx,表示Section header string table index.表示段表字符串表在段表中的下标.
### 3.5 链接的接口--符号
1. 符号的分类
  - 定义在本目标文件中的全局符号,可以被其他目标文件引用.
  - 本目标文件中引用的全局符号,却没有定义在本目标文件,一般叫作外部符号.
  - 段名:符号由编译器产生,它的值就是该段的起始地址.
  - 局部符号:只在编译单元内部可见,调试器使用这些符号来分析程序或者崩溃时的核心存储文件.在链接时没有用,链接器也往往忽略他们
  - 行号信息:目标文件指令与源代码中代码行的对应关系.
2. 符号的查看:使用readelf,objdump,nm等
#### 3.5.1 ELF符号表结构
- 位置:文件中的一个段,段名一般叫做".symtab".本身是一个Elf32\_Sym结构的数组.每个结构对应一个符号

|成员名|信息|
|---|---|
|st\_name|符号名,包含了该符号在字符串表中的下表|
|st\_value|符号值,可能为相对值,可能为绝对值|
|st\_size|符号大小,符号所代表类型的大小|
|st\_info|符号类型和绑定信息|
|st\_other|值为0,未使用|
|st\_shndx|符号所在的段|
- st\_info
  - 低四位表示符号的类型
    |宏定义名|值|说明|
    |---|---|---|
    |STT_NOTYPE|0|未知类型符号|
    |STT_OBJECY|1|该符号是个数据对象,比如变量,数组等|
    |STT_FUNC|2|该符号是个函数或其他可执行代码|
    |STT_SECTION|3|该符号是一个段,这种符号必须是STB_LOCAL的|
    |STT_FILE|4|该符号表示一个文件名,一般都是该目标文件所对应的源文件名,一定是STB_LOCAL类型的,并且st_shndx一定是SHN_ABS|
  - 高28位代表符号绑定信息.
    |宏定义名|值|说明|
    |---|---|---|
    |STB_LOCAL|0|局部符号,对于目标文件的外部不可见|
    |STB_GLOBAL|1|全局符号,外部可见|
    |STB_WEAK|2|弱引用|
- st\_shndx
    - 如果符号定义在本目标文件中,那么这个成员表示符号所在的段在段表中的下表,如果不定义在本目标文件中,则如下表
      |宏定义名|值|说明|
      |---|---|---|
      |SHN_ABS|oxfff1|说明该符号包含了一个绝对的值|
      |SHN_COMMON|oxfff2|表示该符号是一个"COMMON"块.一般来说为初始化的全局符号就是这样定义的|
      |SHN_UNDEF|0|表示该符号未定义,该符号在本目标文件被引用到,但是定义在其他的目标文件中|
- st\_value
    - 在目标文件中,该符号的定义不是"COMMON"块,则st\_value表示该符号在段中的偏移.通过st\_shndx指定段,该值指定偏移,便可以确定变量的位置.
    - 在目标文件中,如果是"COMMON"块,则表示该符号的对齐属性
    - 在可执行文件中,表示符号的虚拟地址.
- readelf -s(--symbols) \*.o
#### 3.5.2 特殊符号
- 特殊符号:当时用ld作为链接器产生可执行文件时,它会为我们定义很多特殊的符号,这些符号没有在程序中定义,但是可以直接声明并且引用它,我们称之为特殊符号.这些符号被定义在ld链接其的链接脚本之中.
  |特殊符号|说明|
  |---|---|
  |\_\_executable\_start|该符号作为程序的起始地址,不是入口地址,是程序最开始的地址|
  |\_\_etext或\_etext或etext|代码段的结束地址,即代码段最末尾的地址|
  |\_edata或edata|该符号为数据段结束地址,即数据段最末尾的地址|
  |\_end或end|该符号为程序的结束地址|
  以上地址都为程序被装载时的虚拟地址.
#### 3.5.3 符号修饰与函签名
