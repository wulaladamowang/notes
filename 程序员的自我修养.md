# 第一部分 简介
## 第一章 温故而知新
### 1.1 从Hello World说起
### 1.2 万变不离其宗
- 南桥：专门处理低速设备
- 北桥：连接高速芯片
- SMP(Symmetrical  Multi-Processing):对称多处理器
- MP(Multi-core Processor):多核心处理器，只保留多个核心，共享比较昂贵的缓存部件
### 1.3 站的高，看的远
- 接口:每个层次之间都要相互通信，既然需要通信就必须需要一个通信协议，我们一般称其为接口。
- 从整个层次结构来看，开发工具和应用程序是属于同一个层次的，因为它们都使用一个接口，那就是操作系统应用程序编程接口。应用程序接口的提供者是运行库，什么样的运行库提供什么样的API,比如在Linux下的Glibc库提供POSIX的API,Windows提供Windows API。
- 运行库使用操作系统提供的系统调用接口(System call interface),系统调用接口在实现中往往以软件中断的方式提供哦你，如Linux使用0x80作为系统调用接口。o
- 硬件规格(Hareware Specification):硬件规格定义了操作系统内核，即驱动程序如何操作硬件，如何与硬件进行通信。
- 总结：应用程序需要使用硬件，首先通过调用系统的API,通过中断进入内核，通过内核中的驱动程序调用相应的硬件。
### 1.4 操作系统做什么
- 提供抽象的接口；管理硬件资源
### 1.5 内存不够怎么办
- 分段、分页、虚拟内存
### 1.6 众人拾柴火焰高
- 线程(Thread)：又名轻量级进程(Lightweight Process,LWP)
  - 组成：线程ID、当前指令指针、寄存器合集、堆栈
- 线程安全：同步与锁
- 三种线程模型
### 1.7 本章小结
# 第二部分 静态链接
## 第二章 编译和链接
### 2.1 被隐藏了什么
- 构建：将编译和链接合并到一起的过程。
- 构建过程的四个步骤：
  - 预处理(Prepressing):.c -> .i  参数：-E
    - 将所有的宏定义删除，并且展开所有的宏定义
    - 处理所有的预编译指令，如#if，#ifdef
    - 处理所有的#include预编译指令，将被包含的文件插入该预编译指令的位置，该过程递归进行
    - 删除所有的注释
    - 添加行号和文件名标识，比如#2”hello.c"2,便于编译时期产生调试用的行号信息以及编译时期产生编译错误或警告信息时能够显示行号。
    - 保留所有的#pragma编译器指令，因为编译器必须要使用他们
      - #pragma是编译器指令，用于指示编译器完成一些特定的动作
      - #pragma 所定义的很多指示字是编译器和操作系统特有的
      - #prama在不同的编译器之间是不可移植的
        - 预处理将忽略#pragma指令
        - 当编译器遇到不认识的#pragma指令时，就会忽略该条指令
        - 两个不同的编译器可能以两种不同的方式解释同一条#pragma指令
        - 一般用法：#pragma parameter
          - message:在大多数的编译器中有相似的信息，在编译时输出消息到编译输出窗口,可以用于代码的版本控制。GCC无法使用,VC实现
          - pack：
                  - 不同类型的数据在内存中按照一定的规则排列;而不是按照顺序一个接一个的排放。
                  - struct内存对齐问题：
                        - 第一个起始于0偏移块
                        - 每个成员按照其类型的大小和指定对齐参数n中比较小的一个进行对齐操作
                                 - 偏移位置与成员占用大小均需要对齐,偏移位置必须为对齐大小的整数倍
                                 - 结构体成员的对齐参数为其所有成员使用的对齐参数的最大值
                        - 结构体总长度必须为所有对齐参数的整数倍

          |对齐参数|结构体内部成员|起始位置|占用大小|是否nop|
          |---|---|---|---|---|
          |1|char|0|1|1|
          |2|short|2|2|0|
          |1|char|4|1|3|
          |4|int|8|4|0|
         ```c
         #pragma pack(8)
         struct s1 {
           short a;
           long b;
         };

        struct s2 {
           char c;
           struct s1 d;
           double e;
         };
         ```

         |对齐参数|结构体内部成员|起始位置|占用大小|是否nop|
         |---|---|---|---|---|
         |2|short|0|2|2|
         |4|long|4|4|0|
         总共占用8个字节,同时,最小对齐数为4
         |对齐参数|结构体内部成员|起始位置|占用大小|是否nop|
         |---|---|---|---|---|
         |1|char|0|1|3|
         |4|struct s1|4|8|4|
         |8|double|16|8|0|
         总共占用24个字节,注意在struct s1进行计算时,采用的是最小对齐数
         在上述操作时,VC支持8字节支持,可以实现,但是gcc不会输出上述,不支持8字节对齐
  - 编译(Compilation):参数-S,可以使用cc1将预编译与编译两个步骤合并 .c->.i->.s
    - 扫描:扫描器
    - 词法分析:运用类似于有限状态机的模型将源代码分解成一系列的记号,一般将记号分为:关键字,标识符,字面量,特殊符号.可以使用lex程序实现词法分析,上述过程会生成一个类似表格的记号表.
    - 语法分析:对扫描器产生的记号进行语法分析,从而生成语法树,分析过程采用上下文无关语法,可以使用Yacc完成上述操作
    - 语义分析:语法分析只能完成语法表达式语法层面的分析,不了解语句的真正含义,如两个指针做乘法没有意义.编译器所做的分析的语义是静态语义,即编译期间能够确定的语义,动态语义是指运行时期才能确定的语义.静态语义一般包括:声明和类型的匹配,类型的转换.经过语义分析之后,整个语法树的表达式都被标识了类型,如果有些类型需要类型转换,则语法树会插入相应的转换节点.
    - 源代码优化:一些整数的加减操作在编译器就可以操作(整数没有赋值操作),则被优化.首先将语法树转化为中间代码,如三地址码.
    - 代码生成:代码转换器将中间代码转换成目标机器代码.
    - 目标代码优化:目标代码优化器对上述目标代码进行进一步优化,对于定义在其他模块的变量,需要通过链接器才能完成.
  - 汇编(Assemble):参数-c,或者使用汇编器as .s->.o
    - 将汇编代码转变成机器可执行的指令
  - 链接(Linking):.o -> 可执行程序 链接器ld
### 2.2 编译器做了什么
   - 见上述编译
### 2.3 链接器年龄比编译器长
   - 重定位:重新计算各个目标的地址的过程.
### 2.4 模块拼接-静态链接
   - 链接:将各个源代码进行独立地编译,按照要求将其组装起来的过程.
   - 链接过程:
        - 地址和空间的分配
        - 符号决议(符号绑定)
        - 重定位:地址修正的过程 重定位入口:每一个被修正的地方称为一个重定位入口.
   - 运行时库(Runtime Library):支持程序运行的基本函数的集合
## 第3章 目标文件里有什么
### 3.1 目标文件的格式
- PC平台流行的可执行文件格式有Windows下的PE(portable Executable)和Linux下的ELF(Executable Linkable Format),它们都是COPP(common File format)的变种.
- 目标文件就是源代码编译后但未进行链接的那些中间文件(Win下的.obj和Linux下的.o),它跟可执行文件的内容和结构很相似,所以跟可执行文件格式采用一种格式存储.
- ELF文件标准里将系统采用ELF格式的文件归为如下:

  | ELF文件类型|说明|实例|
  |---|---|---|
  |可重定位文件(Relocatable File)|这类文件包含数据和代码,用来链接成可执行文件或共享目标文件,静态链接库也是这一类|Linux下的.o,Windows下的.obj|
  |可执行文件(Executable File)|这类文件包含了直接可以执行的程序,它的代表就是ELF可执行文件,一般没有扩展名|Windows的.exe文件,bash文件等|
  |共享目标文件(Shared Object File)|包含数据和代码,可以通过链接器与其他的可重定位文件和共享文件链接形成新的目标文件；可以使用动态链接器将这几个共享目标文件与可执行文件结合,作为进程映像的一部分来运行|Linux的.so,Windows的Dll|
  |核心转储文件(Core Dump File)|当进行意外终止时,系统可以将该进程的地址空间的内容及终止时的一些其他信息转储到核心转储文件|Linux下的core dump|
- linux 下使用file查看相应的文件格式:例子:file foobar.o
- 目标格式与可执行文件格式跟操作系统和编译器密切相关,所以不同的系统平台下有不同的格式,但是格式是大同小异的.
### 3.2 目标文件是什么样的
- 目标文件的内容至少有编译后的机器指令代码数据,还有链接时的一些信息,如符号表,调试信息,字符串等.一般目标文件按照信息的不同属性将其以"节"的形式存储,有时候也称为"段",表示一个一定长度的区域,唯一的区别是在ELF的链接视图和装载视图的时候.
  |结构|内容|
  |---|---|
  |文件头|描述了整个文件的属性,包括文件是否可执行,是静态链接还是动态链接以及入口地址(如果是可执行文件),目标硬件,目标操作系统等,还包括一个段表(Section Table),描述文件中各个段在文件中的偏移位置以及段的属性|
  |各个段|各个段的内容,如代码段保存的就是程序的指令,数据段保存的就是程序的静态变量等|
  |.text|编译后的执行语句|
  |.data|已经初始化的全局变量和局部静态变量|
  |.bss|未初始化的全局变量和局部静态变量,默认值为0,为其预留位置,在文件中没有内容,只存在于虚拟空间而不存在于物理空间|
- 指令和数据分开存储的好处:
  - 数据是可读可写的,指令是只读的,可以对两个虚拟内存的权限分别设置,防止指令被有意或者无意的篡改.
  - 利用局部性原理,提高cpu cache缓存的命中率.
  - 当系统中运行多个程序的副本时,可以共享指令,读改变的数据区域进行拷贝,可以减小内存的使用.
### 3.3挖掘SimpleSection.o
- objdump -h(--section-headers --headers):将ELF文件的各个段的基本信息打印出来,-x(--all-headers)可以将更多的信息打印出来.
  - 属性中的CONTENTS表示段在文件中存在,.bss段没有CONTENTS属性.
- size命令可以查看ELF文件中的代码段,数据段和BSS段的长度,dec表示三个段长度和的十进制表示,hex为十六进制表示.
#### 3.3.1 代码段
- objdump -s(--full-contents)将所有段的内容以十六进制的方式打印出来,-d(--disassemble=[=symbol])将所包含指令的段反汇编.
#### 3.3.2 数据段和只读数据段
- 设置.rodata只读数据段可以支持const变量和字符串常量,同时将该区域映射成只读,可以保证程序的安全性.
#### 3.3.3 BSS段
- 不同的编译器不同的语言可能不会将全局的未初始化变量存放.bss段,只是预留一个未定义的全局变量符号,等到最终链接成可执行文件时再在.bss段分配空间,编译器内部可见的静态变量的确放在.bss段.
#### 3.3.4其他段
| 常用的段名| 说明|
|---|---|
|.rodata1|Read only data, 只读数据,比如字符串常量,全局const变量,跟.rodata一样|
|.comment|存放的是编译器信息,如字符串:"GCC:(GUN)4.2.0"|
|.debug|调试信息|
|.dynamic|动态链接信息|
|.hash|符号哈希表|
|.line|调试信息的行号,即源代码行号与编译后指令的对应表|
|.note|额外的编译器信息,如程序的公司名,发布版本号等|
|.strtab|String Table.字符串表,用于存储ELF文件中用到的各种字符串|
|.symtab|Symbol Table.符号表|
|.shstrtab|Section String Table.段表名|
|.plt .got|动态链接的跳转表和全局入口表|
|.init, .fini|程序初始化和终结代码段|
- .为前缀表明系统保留的,可以应用程序自定义段名,但是不能以.为前缀.
- 段名可以重复
- 使用objcopy可以将一个二进制文件如图片,MP3等作为目标文件的一个段.
- GCC:在全局变量或者函数之前加上"__attribute__((section("name")))"属性可以将相应的变量或者函数放到以"name"作为段名的段中.
### 3.4 ELF文件结构描述
  |结构|
  |---|
  |ELF Header|
  |.text|
  |.data|
  |.bss|
  |...<br>other sections|
  |Section header table|
  |String Tables<br>Symbol Tables|
#### 3.4.1 文件头
- 定义位置:/usr/include/elf.h中
- 使用readelf命令来详细查看ELF文件. 参数-h(--file-header)
- 文件头定义的内容有ELF魔数,文件机器字节长度,数据存储方式,版本,运行平台,ABI版本,ELF重定位类型,硬件平台,硬件平台版本,入口地址,程序头入口和长度,段表的位置和长度以及段的数量等.
- 文件头的版本有ELF32\_Ehdr和ELF64\_Ehdr.
- ELF魔数:e\_ident成员表示,最开始的4个字节是所有的ELF文件都必须相同的表示,0x7f,0x45,0x4c,0x46.这四个字节称为ELF文件的魔数,接下来的一个字节是标识ELF文件的文件类的,32位为0x01,64位为0x02.第6个字节是标识字节序的,大小端,第7个字节规定ELF文件的主版本号,一般是1,自1.2版本之后就没有再更新了,后面9个没有定义,一般为0,有些平台使其为扩展标志.
- 文件类型:e\_type,可重定位文件,可执行文件,共享文件每个对应一个常量,通过该常量可以判断文件的类型,而不是通过文件的扩展名.- 机器类型:ELF文件格式可以在多个平台下使用,但是,不代表同一个ELF文件可以在不同的平台下使用,而是表示不同平台下的ELF文件都尊需同一套ELF标准.e\_machine表示该ELF文件的平台属性,表示该文件只能在该平台下使用.
#### 3.4.2 段表
- 段表(Section Header Table):保存ELF文件中段的基本属性的结构,主要包含信息有:段名,段的长度,在文件中的偏移,读写权限以及段的其他属性.它是编译器,链接器以及装载器定位和访问各个段的依据.其本身的位置由e\_shoff成员决定.
- readelf -S(--section-headers) 可以显示段表的内容.段表是以ELF32\_Shdr结构体为元素的数组,每个结构体对应一个段,Elf32\_Shdr又被称为段描述符.第一个元素为无效的描述符,类型为"NULL".
- 段的类型:段的名字只在编译和链接过程中有意义,而对操作系统而言,一个段的属性和权限由段的类型和标志位两个成员来决定.
#### 3.4.3 重定位表 代码或者数据在文件中的绝对引用在后续过程中需要重定位,每个需要重定位,其对应相应的重定位表.
#### 3.4.4 字符串表
- 将用到的变量和段名保存在字符串表中,在引用时只需要引用下标,保存.strtab或.shstrtab分别表示字符串表和段表字符串表(String table and Section header string table),e\_shstrndx,表示Section header string table index.表示段表字符串表在段表中的下标.
### 3.5 链接的接口--符号
1. 符号的分类
  - 定义在本目标文件中的全局符号,可以被其他目标文件引用.
  - 本目标文件中引用的全局符号,却没有定义在本目标文件,一般叫作外部符号.
  - 段名:符号由编译器产生,它的值就是该段的起始地址.
  - 局部符号:只在编译单元内部可见,调试器使用这些符号来分析程序或者崩溃时的核心存储文件.在链接时没有用,链接器也往往忽略他们
  - 行号信息:目标文件指令与源代码中代码行的对应关系.
2. 符号的查看:使用readelf,objdump,nm等
#### 3.5.1 ELF符号表结构
- 位置:文件中的一个段,段名一般叫做".symtab".本身是一个Elf32\_Sym结构的数组.每个结构对应一个符号

|成员名|信息|
|---|---|
|st\_name|符号名,包含了该符号在字符串表中的下表|
|st\_value|符号值,可能为相对值,可能为绝对值|
|st\_size|符号大小,符号所代表类型的大小|
|st\_info|符号类型和绑定信息|
|st\_other|值为0,未使用|
|st\_shndx|符号所在的段|
- st\_info
  - 低四位表示符号的类型
    |宏定义名|值|说明|
    |---|---|---|
    |STT_NOTYPE|0|未知类型符号|
    |STT_OBJECY|1|该符号是个数据对象,比如变量,数组等|
    |STT_FUNC|2|该符号是个函数或其他可执行代码|
    |STT_SECTION|3|该符号是一个段,这种符号必须是STB_LOCAL的|
    |STT_FILE|4|该符号表示一个文件名,一般都是该目标文件所对应的源文件名,一定是STB_LOCAL类型的,并且st_shndx一定是SHN_ABS|
  - 高28位代表符号绑定信息.
    |宏定义名|值|说明|
    |---|---|---|
    |STB_LOCAL|0|局部符号,对于目标文件的外部不可见|
    |STB_GLOBAL|1|全局符号,外部可见|
    |STB_WEAK|2|弱引用|
- st\_shndx
    - 如果符号定义在本目标文件中,那么这个成员表示符号所在的段在段表中的下表,如果不定义在本目标文件中,则如下表
      |宏定义名|值|说明|
      |---|---|---|
      |SHN_ABS|oxfff1|说明该符号包含了一个绝对的值|
      |SHN_COMMON|oxfff2|表示该符号是一个"COMMON"块.一般来说为初始化的全局符号就是这样定义的|
      |SHN_UNDEF|0|表示该符号未定义,该符号在本目标文件被引用到,但是定义在其他的目标文件中|
- st\_value
    - 在目标文件中,该符号的定义不是"COMMON"块,则st\_value表示该符号在段中的偏移.通过st\_shndx指定段,该值指定偏移,便可以确定变量的位置.
    - 在目标文件中,如果是"COMMON"块,则表示该符号的对齐属性
    - 在可执行文件中,表示符号的虚拟地址.
- readelf -s(--symbols) \*.o
#### 3.5.2 特殊符号
- 特殊符号:当时用ld作为链接器产生可执行文件时,它会为我们定义很多特殊的符号,这些符号没有在程序中定义,但是可以直接声明并且引用它,我们称之为特殊符号.这些符号被定义在ld链接其的链接脚本之中.
  |特殊符号|说明|
  |---|---|
  |\_\_executable\_start|该符号作为程序的起始地址,不是入口地址,是程序最开始的地址|
  |\_\_etext或\_etext或etext|代码段的结束地址,即代码段最末尾的地址|
  |\_edata或edata|该符号为数据段结束地址,即数据段最末尾的地址|
  |\_end或end|该符号为程序的结束地址|
  以上地址都为程序被装载时的虚拟地址.
#### 3.5.3 符号修饰与函签名
- 符号修饰或符号改编
- 函数签名:函数签名包含了一个函数的信息,包括函数名,它的参数类型,它所在的类和名称空间及其他信息.
#### 3.5.4 extern "C"
- C++编译器咋会将extern "C"的大括号内的代码当作C语言处理,所以经过extern "C"代码修饰之后,C++的名称修饰机制将不会再起作用
- 对于使用了c语言的函数时,由于C++编译器会按照C++编译的标准进行符号修饰,使得其与c语言库中的符号不相同,从而使得链接器无法进行链接,需要使用extern "c"使得按照c语言的方式进行编译,从而进行链接.但是C语言本身不支持extern "C"这种形式,从而使得得定义两套头文件.为了解决上述问题,采用宏方式.例如
```c
#ifdef __cplusplus
extern "C" {
#endif

void *memset (void *, int, size_t);

#ifdef __cplusplus
}
#endif
```
  因为C++编译器默认会使用上述宏\_\_cplusplus,可以使用条件宏来判断当前编译单元是不是c++代码.
#### 3.5.5 弱符号与强符号
- 强符号:编译器默认函数和初始化了的全局变量为强符号
- 弱符号:编译器默认未初始化的全局变量为弱符号
- 强符号和弱符号都是针对定义来说的,不是针对符号的引用.例如 extern int ext;无强弱符号之说.
- 通过GCC的"\_\_attribute\_\_((weak))"来定义任何一个强符号为弱符号.
- 强弱符号规则
  - 不允许强符号被多次定义；多个强符号定义,链接器报告符号重复定义错误
  - 如果一个符号在一个文件中是强符号,在其他文件中都是若符号,则选择强符号
  - 如果一个符号在所有的目标文件中都是弱符号,则选择占用空间最大的一个.
- 强引用和弱引用
  - 如果外部目标文件的符号引用在最终链接为可执行文件时没有找到符号的定义,则链接器会报符号未定义错误,这种被成为强引用.
  - 如果符号有定义,则链接器将该符号的引用决议,如果未定义,则链接器对于该引用不报错,称为弱引用.使用\_\_attribute\_\_((weakref))扩展字来声明对一个外部函数的引用为弱引用.通过判断弱引用是否为Null可以判断是否可加载.
### 3.6 调试信息
- 在GCC编译时添加"-g"参数可以添加调试信息.
- ELF文件使用DWARF(Debug With Arbitrary Record Format)的标准的调试信息格式.
- 使用strip命令除去ELF文件中的调试信息.
## 第4章 静态链接
### 4.1 空间与地址分配
#### 4.1.2 相似段合并
- 链接器为目标文件分配地址和空间的地址和空间包含两个含义
  - 在输出的可执行文件中的地址
  - 装载后的虚拟地址中的虚拟地址空间.
  - 对.text与.data这样的段来说,文件中和虚拟地址中都需要分配空间,因为其两者都存在;对.bss这样的段来说,分配空间的意义只是局限于虚拟地址空间.
- 采用两步链接的方式
  - 空间与地址的分配
    - 扫描所有的输入文件,获取各个段的长度,属性和位置,并将输入目标文件中的符号表中所有的符号定义和符号引用收集起来,统一放到一个全局表中.可以计算输出文件中各个段的长度和位置,并建立映射关系.
  - 符号解析与重定位
    - 使用上一步收集到的所有信息,读取输入文件中段的数据,重定位信息,并且进行符号解析与重定位,调整代码中的位置等.
- 使用 ld链接器将.o文件进行链接.
- 默认情况下,ELF可执行文件的默认分配地址不是0开始.
#### 4.1.3 符号地址的确定
- 通过分配结束之后,各个符号的位置已经确定,链接器对全局符号表进行更新.
### 4.2 符号解析与重定位
#### 4.2.1 重定位
- call:近址相对位移调用指令,后面4个字节是被调用函数想对于调用指令的下一条指令的偏移量.
#### 4.2.2 重定位表
- ELF文件中有一个重定位表的结构专门用来保存与重定位有关的信息. .text的需要被重定位的地方,相应的叫做 .rel.text,代码段.data需要被重定位的地方,.rel.data.
- 使用objdump -r(--reloc) 查看目标文件的重定位表.
- 重定位入口:每个需要被重定位的地方.
- 重定位表的数据结构
```c
typedef struct {
  Elf32_Addr r_offset;// 重定位入口的偏移,对于可重定位文件来说,为重定位入口所要修正的地一个字节相对于段起始地址的偏移；对于可执行文件和共享对象文件来说,这个值应该是该重定位入口所要修正的位置的第一个字节的虚拟地址.
  Elf32_Word r_info;// 重定位入口的类型和符号,低8位表示重定位入口的类型,高24位表示重定位入口的符号在符号表中的下标.
}Elf32_Rel;
```
- 理解:通过重定位表,可以获得要修正的符号的在本段的位置信息,r\_info通过获得在符号表中的信息,可以获得符号的真实信息.
#### 4.2.3 符号解析
- 重定位的过程也伴随着符号解析的过程.当链接器需要对某个符号的引用进行重定位时,它就要确定这个符号的目标地址,这时候链接器就需要查找所有输入目标文件的符号表组成的全局符号表,找到相应的符号之后进行重定位.
- 如果在全局符号表中不能找到符号,则会报未定义错误.(undefined).
#### 4.2.4 指令修正方式
- 不同的处理器指令对于地址的格式和方式都不一样.
- 重定位入口的r\_info成员低8位表示重定位入口类型.分为绝对寻址修正和相对寻址修正.
  |宏定义|值|重定位修正方法|
  |---|---|---|
  |R\_386\_32|1|绝对寻址修正 S+A|
  |R\_386\_PC32|2|相对寻址修正 S+A-P|
  A = 保存在被修正位置的值
  P = 被修正的地址(相对于段开始的偏移量或者虚拟地址),该值可以通过r\_offset计算得到
  S = 符号的实际地址,即由r\_info的高24位指定的符号的实际地址
### 4.3 COMMON块
- 链接器对变量的类型并不了解,只能知道符号的名字.
- 编译器将未初始化的全局变量定义为弱符号处理.
- 问题:为什么编译器不直接将未初始化的全局变量当作未初始化的局部静态变量处理,为其在BSS段分配空间,而是将其标记为一个COMMON段?  答:编译器编译时,局部静态变量本身的大小不受外部文件的干扰,所以在编译时就可以确定大小从而分配空间,但是,全局变量的大小最终所占的空间大小是位置的,其大小受到外界的干扰,因为有可能其他编译单元的符号的空间占用比本编译模块要大.但是在链接器进行链接之后,弱符号的大小都可以确定了,所以在输出文件的BSS段可以为其分配空间.
- 使用-fon-common参数允许我们将所有的为初始化的全局变量不以COMMON块的形式处理,或者使用\_\_attribute\_\_((nocommon)).此时的符号相当于强符号.
### 4.4 C++相关问题
#### 4.4.1 重复代码消除
- 对于模板的实例代码的重复消除:将每个模板的实例代码都单独放在一个段里,每个段都只包含一个模板实例,比如,有个模板函数是add<T>(),某个编译单元以int 类型和float类型实例化该模板,编译单元的目标文件中就会包含了两个该模板实例的段,假设这两个段的名字分别为.temp.add<int>和.temp.add<float>,这样当别的编译器单元也以int或float类型实例化该模板函数之后,也会生成同样的名字,在链接器在最终链接的时候就会区分这些相同的模板实例代码,然后将他们合入到最后的代码段.
- 上述消除重复代码的方式在外部内联函数以及虚函数表中的做法也是类似的.还有默认构造函数,默认拷贝构造函数和赋值操作符.
- 如果在合并段的时候,相同名称的段可能拥有不同的内容,则链接器可能会随便选择一个副本作为链接的输入,然后同时提供一个警告.
- 函数级别的链接
  - 让所有的函数单独保存在一个段中,当链接器需要用到某个函数时,就会将它合并到输出文件中,对于没有用到的文件就将它抛弃.优点是可以减小输出文件的长度,减小空间浪费；缺点:减慢编译和链接的过程,因为链接器必须计算每个函数之间的依赖关系,并且所有的函数都存在独立的段中,目标函数的段的数量会大大增加,重定位过程也会因为段的数目的增加而变得复杂,目标文件随着段数目的增加也会变得相对较大.
  - GCC编译器采用-ffunction-sections和-fdata-sections两个选项将每个函数和变量分别保存在独立的段中.
#### 4.4.2 全局构造和析构
- linux系统下一般程序的入口是\_start, 位于Glibc中的一部分.
- .init段 保存可执行指令,构成了进程的初始化代码,Glibc的初始化安排在main函数调用之前调用
- .fini段 保存着进程终止代码指令,Glibc安排在main()函数正常退出时执行.
- 依据上述两个特性,c++的全局构造和析构函数就此实现.
#### 4.4.3 C++与ABI
- ABI:将符号修饰,变量内存布局,函数调用方式等这些跟可执行代码二进程兼容性相关的内容称为Application Binary Interface.它的诞生是希望程序能够不加修改的情况下得到重用.
- ABI为二进制层面的接口,API为源代码级别的接口.例如printf()保证了遵循POSIX标准的系统之间的定义相同,却不能保证函数的二进制层面相同,如压栈顺序.
- 当用户的编译器型号和版本与编译库所用的编译器型号和版本不同时,就可能产生不兼容.因为在两个编译器编译出的同样的函数名称却符号不同,则链接自然是失败的.
### 4.5 静态库链接
- 静态库:可以简单的看成一组目标文件的集合,即很多目标文件经过压缩打包之后形成的一个文件.
- 使用ar工具查看文件中包含的目标文件,使用ar工具将目标文件压缩到一起,并对其进行编号和索引.
- 使用objdump -t(--syms)查看函数所在的目标文件,grep.
- 使用gcc中的--verbose参数将整个编译链接的过程的中间步骤打印出来.
- 为什么静态运行库的一个目标文件只是包含一个函数?答:静态链接库是以目标文件为单位的,当很多函数都在一个目标文件时,在链接函数时,会链接整个目标文件,从而同时引进不需要的函数.单独形成目标文件可以减小空间浪费,将没用的目标文件不会链接到最终的输出文件当中.
### 4.6 链接过程控制
- 使用ld -T(--scriptfile)使用自定义的链接脚本.
- 链接脚本的组成一般有两部分,一种是命令语句,另一种是赋值语句.
  - 语句之间使用分号作为分割符号
  - 表达式和运算符
  - 注释和字符引用 /* */作为注释.
  - page130
# 第三部分 装载与动态链接
## 第6章 可执行文件的装载与进程
### 6.1 进程虚拟地址空间
- Windows下碰到令人讨厌的"进程因非法操作需要关闭"或者linux下的Segmentation fault很多时候是因为进程访问了未经允许的地址.
- PAE:Intel使用的映射方式可以是的访问更多的物理内存.Physical Address Extension.
- 32位的cpu下,程序使用的虚拟地址空间不能够超过4GB,但是计算机的内存空间可以.使用窗口映射的方式可以使得将额外的物理内存映射到进程地址空间中.例如,虚拟地址空间需要0x10000000-0x20000000这个256MB做创窗口,那么程序可以从大于4GB的空间中申请多个256MB的物理空间,并进行编号,根据使用,将虚拟地址空间映射到不同的物理地址空间.在Windows下使用AWE(address windowing extensions),在linux中可以使用mmap()系统调用来实现.
### 6.2 装载的方式
- 程序的运行具有局部性原理,可以将程序中最常用的部分驻留在内存之中,将一些不太常用的数据放在磁盘里,这就是动态装入的基本原理.动态装入的基本思想是用到哪个模块就将哪个模块装入内存,如果不用就暂时不装入,存放在磁盘中.
- 覆盖装入和页映射(Overlay and Paging)是两种很典型的动态装载的方法.
#### 6.2.1 覆盖装入
- 程序员手写覆盖管理器(overlay manager)一个辅助代码来管理将程序的哪些模块驻留内存,而何时被替换掉.覆盖管理器要手工按照他们之间的依赖关系组织成树状结构.因为程序运行时,要保证依赖都在内存中.
- 覆盖管理器要保证两点:
  - 这个树状结构从任何一个模块到树的根叫做调用路径,当模块被调用时,这个调用路径上的所有模块都应该在内存中.以保证函数的正确返回.
  - 禁止跨树间调用.任何一个模块不允许跨过树状结构进行调用.因为覆盖管理器不能够保证跨树间的模块能够存在于内存之中.如果跨树的模块运用到同一个模块,可以将模块并到它们的公共祖先节点模块之上.
- 覆盖模块的调用比较慢.
#### 6.2.2 页映射
- 将内存和磁盘中所有的数据和指令按照页(page)为单位进行划分,以后所有的装载和操作的单位就是页.
### 6.3 从操作系统角度看可执行文件的装载
#### 6.3.1 进程的建立
- 从操作系统来看,一个进程最关键的特征就是它拥有独立的虚拟地址空间,这使得他有别于其他的进程.
- 一个程序被执行伴随着一个新的进程被创建
  - 创建一个独立的虚拟地址空间
    - 虚拟地址空间由一组映射函数将虚拟地址空间的各个页映射到相应的物理地址.创建虚拟地址不是创建空间而是创建映射函数所需要的相应的数据结构,在i386的linux下,创建虚拟地址空间只是分配一个页目录(page directory)就可以了,不会设置映射关系,等到后续程序发生页错误的时候再进行设置.
  - 读取可执行文件头,并且建立虚拟空间与可执行空间的映射关系
    - 在上述第一步过程中,当发生页错误时,系统从物理空间分配一个物理页,然后建立缺页与物理页的映射关系.我们需要知道程序当前所需要的页在可执行文件的哪一个位置,这就是虚拟地址空间与可执行文件之间的映射关系.由于可执行文件在转载时实际上是被映射到虚拟地址空间,因此可执行文件有很多时候又被称为映像文件(Image).这种映射关系只是保存在操作系统内部的一个数据结构,Linux中将进程虚拟地址空间中的一个段叫做虚拟内存区域(VMA, Virtual Memory Area);Windows中叫做虚拟段(Virtual Section).
  - 将CPU的指令寄存器设置成可执行文件的入口地址,启动运行.
    - 整个过程会涉及内核堆栈和用户堆栈的切换,CPU运行权限的切换等.ELF文件头中保存有入口地址,我们可以简单认为该步骤操作系统执行了一条跳转指令,直接跳到可执行文件的入口地址.
#### 6.3.2 页错误
### 6.4 进程虚拟空间分布
#### 6.4.1 ELF文件链接视图和执行视图
- 段的权限的组合
  - 以代码段为代表的权限为可读可执行的段
  - 以数据段和BSS段为代表权限为可度可写的段
  - 以只读数据段为代表的权限为只读的段
- 为了减少段的数量多,以页为单位进行映射造成内存浪费的问题,一种简单的解决问题的方案为对于相同 权限的段,把它们合并到一起当作一个段进行映射.
- ELF可执行文件引入了一个概念叫做"Segment",一个"Segment"包含一个或者多个属性类似的Section.通过相同属性的段的合并,可以减小页面内部的浪费,从而节省了内存空间.
- 从链接的角度来看,ELF文件是按照Section存储的,事实也确实如此,从装载的角度来看,ELF文件可以按照"Segment"划分.
- 注意上述过程中section指的是段,这个段是指.text,.data这样的段.segment指的是按照属性重新链接之后的段.
- 系统是按照segment来映射可执行文件的.
- realelf -S(--section-headers| --sections)来读取section,readelf -l(--program-headers|--segments)来读取segment,描述segment的结构叫做程序头(Program Header),它描述了ELF文件该如何被系统映射到进程的虚拟空间.
- ELF可执行文件有一个专门的数据结构叫做程序头表(Program Header Table)用来保存Segment信息.因为ELF文件不需要被装载,所以他没有程序头表,而ELF的可执行文件和共享库文件都有.
  |成员|含义|
  |---|---|
  |p\_type|Segment的类型,LOAD的类型为1,只有这个类型的段会被映射|
  |p\_offset|Segment在文件中的偏移|
  |p\_vaddr|Segment的第一个字节在进程虚拟地址空间的起始位置, 在整个程序头中,所有的LOAD类型的元素按照p\_vaddr从小到大排列|
  |p\_paddr|Segment的物理装载地址,就是LMA(Load Memory Address)的概念|
  |p\_filez|Segment在ELF文件中所占空间的长度,它的值也可能是0|
  |p\_memse|Segment在进程虚拟地址空间中所占用的长度,它的值也可能是0|
  |p\_flags|Segment的权限属性,比如可读,写,执行|
  |p\_align|对齐属性|
#### 6.4.2 堆和栈
- 主设备和次设备号及文件节点都为0,表示它们没有映射到文件中,这种VMA叫做匿名虚拟内存区域(Anonymous Virtual Memory Area).
- vdso,位于内核的一个模块,进程可以通过这个来与内核进行一些通讯.
#### 6.4.3 堆的最大申请数量
#### 6.4.4 段地址对齐
- 当将可执行文件的段装载到内存空间时是尽可能的连续,为了保证对每个页的权限,可以将同一个页在虚拟地址空间中映射为两个,前后差了一个段,这样可以使得偏移容易计算,同时使得装载到内存时减少内存碎片.
### 6.5 Linux内核装载ELF过程简介
- 在用户层面,bash进程会调用fork()系统调用创建一个新的进程,然后新的进程调用execve()系统调用执行指定的ELF文件,原先的bash进程继续返回等待刚才启动的进程结束,然后继续等待用户输入命令.
- execve()系统调用三个参数分别是执行的程序文件名,执行参数和环境变量.
- execve()调用sys\_execve(),然后调用do\_exec().
- do\_exec()首先会找到执行的文件,如果找到文件,就读取文件的前128个字节,来判断文件的格式,开头的四个字节称为魔数,可以确定文件的格式和类型.
- 读取128个字节的文件之后,然后调用search\_binary\_handle()去搜索和匹配合适的可执行文件装载处理过程.通过魔数调用相应的装载处理过程,其中elf文件的叫做load\_elf\_binary().
- load\_elf\_binary()的主要步骤有
  - 检查elf文件的有效性,比如魔数,程序头表中段的数量
  - 寻找动态链接.interp段,设置动态链接器路径
  - 根据elf可执行文件的程序头表的描述,对ELF文件进行映射,比如代码,数据,只读数据
  - 初始化elf进程执行环境
  - 根据系统调用的返回地址修改成elf可执行文件的入口点,这个入口点取决于程序的链接方式,对于静态链接的elf可执行文件,这个程序的入口就是elf文件的文件头中e\_entry所指的地址,对于动态链接的elf可执行文件,程序入口点是动态链接器.
- 上述调用层层返回,到sys\_execve(),系统调用的返回地址已经改成了被装载的elf程序的入口地址.所以从sys\_execve()系统调用从内核态返回到用户态时,EIP寄存器就直接跳到了elf程序的入口地址,新的程序执行,elf可执行文件装载完成.

